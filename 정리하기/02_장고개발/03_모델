/ 장고기본요소 /

장고 개발을 하는데 필요한 기본내용을 익히자

/ 목표 /

1. urls.py 파일을 이용해 URL과 매핑되는 view 함수를 관리하기
2. 장고 ORM을 이용해 데이터베이스를 제어하기
3. 파이보 게시판에 질문 목록과 질문 상세 기능을 만들기


2. 장고 ORM을 이용해 데이터베이스를 제어하기


/ -- 1. 모델 /


장고는 모델(Model)을 이용하여 데이터베이스를 처리한다. 보통 데이터베이스에 데이터를 저장하고 조회하기 위해서는 SQL쿼리문을 이용해야 하지만 장고의 모델(Model)을 사용하면 이런 SQL쿼리문의 도움없이 데이터를 쉽게 처리할 수 있다.


서버를 구동할 때 나오는 확인문을 읽어보면 이와같은 문구가 있다.

Ex) 
    You have 18 unapplied migration(s). Your project may not work properly until you apply the migrations for app(s): admin, auth, contenttypes, sessions.
    Run 'python manage.py migrate' to apply them.

18개의 적용되지 않은 migrations가 있다는 문구가 있다. admin, auth, session, contenttypes 앱들과 관련된 내용이고 이것을 적용하려면 python manage.py migrate 를 실행해야 한다고 나와있다. 위와 같은 앱들은 장고 프로젝트 생성시 자동으로 설치되는 앱들이다.


// config.setting.py

Ex) 
    INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

위에 언급된 앱들외에 messages 와 staticfiles 앱들도 추가로 보인다. 이 두개의 앱은 데이터베이스와 상관이 없는 앱이기에 경고문에 포함되지 않는다.

즉, 데이터베이스가 필요한 앱만 migrate 가 필요하다.


// config/setting.py

파일안에 DATABASE 영역을 살펴보면 

Ex)
    DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

장고에서 데이터베이스 엔진은 'django.db.backends.sqlite3' 라고 정의되어 있다.

그리고 데이터 베이스 파일은 BASE_DIR 디렉터리 밑에 db.sqlite3 파일에 저장한다고 정의되어 있다.

BASE_DIR 은 프로젝트 디렉터리를 의미한다.

이 프로젝트의 BASE_DIR은 C:\projects\mysite 이다.

SQLite에 대하여
SQLite는 주로 개발용이나 소규모 프로젝트에서 사용되는 가벼운 파일 기반의 데이터베이스이다. 개발시에는 SQLite를 사용하여 빠르게 개발하고 실제 운영시스템은 좀 더 규모있는 DB를 사용하는 것이 일반적인 개발 패턴이다.

이제 python manage.py migrate 를 명령프롬프트에서 실행해서 해당 앱들이 필요로 하는 데이터베이스 테이블들을 생성하자


Ex) 
  (mysite) C:\projects\mysite>python manage.py migrate


migrate 를 수행하면 admin, auth, sessions, contenttypes 앱들이 사용하는 하는 테이블들이 생성된다.



/ --2. DB Browser for SQLite /

어떤 테이블들이 만들어지는지 확인하고 싶다면, SQLite의 GUI도구인 "DB Browser for SQLite" 를 설치하면 데이터 베이스의 테이블들을 확인할 수 있다.

자동으로 생성된 테이블의 내용을 자세히 볼 필요는 없다. 장고의 장점 중 하나는 테이블 작업을 위해 직접 쿼리문을 수행하지 않아도 된다는 점이다.

장고의 ORM(Object Relational Mapping)을 사용하면 쿼리문을 몰라도 데이터 작업을 쉽게 할 수 있다.

ORM
전통적으로 데이터베이스를 사용하는 프로그램들은 데이터베이스의 데이터를 조회하거나 저장하기 위해 쿼리문을 사용해야 했다. 이 방식은 여전히 많이 사용되고 있는 방식이지만 몇 가지 단점이 있다. 개발자마다 다양한 쿼리문이 만들어지고, 또 잘못 작성된 쿼리는 시스템의 성능을 저하 시킬수 있기 때문이다. 그리고 데이터베이스를 MySQL에서 오라클로 변경하면 프로그램에서 사용한 쿼리문을 모두 해당 데이터베이스의 규칙에 맞게 수정해야 하는 어려움도 생긴다.

ORM(Object Relational Mapping)을 사용하면 데이터베이스의 테이블을 모델화하여 사용하기 때문에 위에서 열거한 SQL방식의 단점이 모두 없어진다. "ORM을 사용하면 개발자별로 독특한 쿼리문이 만들어질 수가 없고 또 쿼리를 잘못 작성할 가능성도 낮아진다. 그리고 데이터베이스 종류가 변경되더라도 쿼리문이 아닌 모델을 사용하기 때문에 프로그램을 수정할 필요가 없다."



3. 파이보 게시판에 질문 목록과 질문 상세 기능을 만들기

/ -- 3. 모델 작성하기 /

이제 파이보가 사용할 데이터 모델을 만들어 보자. 파이보는 질문과 답변을 할 수 있는 파이썬 게시판 서비스이다. 따라서 파이보에는 "질문과 답변에 해당하는 데이터 모델"이 있어야 한다.


/ 3.1 모델의 속성 /

질문과 답변에는 최소한 다음과 같은 속성값들이 필요하다.


Ex)
    "Question 모델"

  subject / 질문의 제목
  content / 질문의 내용
  create_date / 질문을 작성한 일시

    "Answer 모델"
  
  question / 질문
  content / 답변의 내용
  create_date / 질문을 작성한 일시

"Answer 모델" 에서 질문이 필요한 이유는, 어떤 질문의 답변인지 알아야하므로 질문 속성이 필요하다.


이제 최소한으로 갖추어야 하는 모델의 속성을 알았기 때문에, 이 모델들을 작성해 보자.


/ 3.2 models.py /

// pybo/models.py


Ex) 
    from django.db import models
    
    class Question(models.Model):
    subject = models.CharField(max_length=200)
    content = models.TextField()
    create_date = DateTimeField()

    class Answer(models.Model):
    question = models.ForeignKey(Question, on_delete = models.CASCADE)
    content = models.TextField()
    create_date = DateTimeField()

"Question 모델" 은 제목(subject), 내용(content), 작성일시(create_date)를 속성으로 갖도록 작성했다.

    "models.CharField(max_length=200)" 과 같이 길이가 제한된 텍스트는 CharField함수를 사용해야 한다.

    "models.TextField()" 과 같이 길이제 제한을 두지 않아도 되면 TextField 함수를 사용하면 된다.

    "DateTimeField()" 날짜처럼 시간과 관련된 속성은  DateTimeField 함수를 사용하면 된다.


"Answer 모델" 은 질문(Question), 내용(content), 작성일시(create_date) 를 속성으로 갖는다. "Answer 모델" 은 질문에 대한 답변을 위하기에 절대적으로 질문을 받아와야 한다.


    "models.ForeignKey(Question, on_delete = models.CASCADE)" 
    그래서 기존모델의 속성을 받아오기 위해서 "ForignKey" 함수가 필요하다. "ForignKey" 은 다른 모델과 연결하기 위해 사용한다.
    "on_delete = models.CSCADE" 의 의미는 이 답변과 연결된 "Question 질문" 이 삭제될 경우 "Answer 답변" 도 함깨 삭제된다는 의미이다.


/ 3.2 테이블 생성하기 /

작성한 모델을 이용하여 테이블을 생성해야 한다. 테이블 생성을 위해 가장 먼저 해야 할 일은 pybvo앱을 "config/setting.py" 파일의 "INSTALLED_APPS" 항목에 추가해야 한다.

"config/setting.py"

Ex) 
    INSTALLED_APPS = [
        'pybo.apps.PyboConfig',
        ...
    ]

'pybo.apps.PyboConfig' 앱은 pybo앱을 만들면 자동으로 생성되는 파일명이다. 경로 "pybo.apps.py" 에 들어가보면 이미 클래스가 구현되어 있다.


Ex)
    from django.apps import AppConfig


    class PyboConfig(AppConfig):
        default_auto_field = 'django.db.models.BigAutoField'
        name = 'pybo'

특별한 경우가 아니라면 수정할 일은 거의 없다.


/ 3-3 makemigrations /

Django에서 Model 클래스를 생성하고 난 후, 해당 모델에 상응하는 테이블을 DATABASE 에서 생성할 수 있다. Python 모델 클래스의 수정 및 생성을 DB에 적용하는 과정을 Migration이라고 부른다. 이는 장고가 기본적으로 제공하는 ORM서비스를 통해 진행된다.

이제 "Question 모델", "Answer 모델" 을 데이터베이스 테이블에 생성해보자

Ex) 
    c:\Myprojects\mysite>python manage.py makemigrations


명령어를 실행해 변경사항에 대한 마이그레이션 파일을 생성한다.

Ex)
    c:\Myprojects\mysite>python manage.py migrate
    Migrations for 'pybo':
    "pybo\migrations\0001_initial.py"
    - Create model Question
    - Create model Answer

그 다음 변경사항을 데이터베이스에 적용하면 다음과 같이 "Question 모델" 과 "Answer 모델" 이 생성되는 것을 확인할 수 있다.

"makemigrations" 는 모델을 생성하거나 모델에 변화가 있을 경우에 실행해야 하는 명령이다. 이 명령을 실행하면 자동으로 "pybo\migrations\0001_initial.py" 라는 파이썬 파일이 자동으로 생성된다.

"sqlite3" 를 실행시켜서 db.sqlite3 파일을 실행해보면 "pybo_question 모델" 과 "pybo_answer 모델" 이 만들어진 것을 확인 할 수 있다.

/ 4.Sqlmigrate /

makemigrations 로 데이터베이스 작업 파일을 생성하고 migrate 명령을 실행하기 전에 실제 어떤 쿼리문이 실행되는지 "Sqlmigrate" 명령으로 확인해 볼 수 있다.

Ex) 
    (mysite) c:\projects\mysite> python manage.py sqlmigrate pybo 0001

    BEGIN;
    --
    -- Create model Question
    --
    CREATE TABLE "pybo_question" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "subject" varchar(200) NOT NULL, "content" text NOT NULL, "create_date" datetime NOT NULL);
    --
    -- Create model Answer
    --
    CREATE TABLE "pybo_answer" ("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, "content" text NOT NULL, "create_date" datetime NOT NULL, "question_id" bigint NOT NULL REFERENCES "pybo_question" ("id") DEFERRABLE INITIALLY DEFERRED);
    CREATE INDEX "pybo_answer_question_id_e174c39f" ON "pybo_answer" ("question_id");
    COMMIT;

"python manage.py sqlmigrate pybo 0001" 명령에서 "pybo" 는 앱이름을 의미하고 "0001" 은 생성된 파일의 일련번호를 의미한다.


/ 5. 모델 사용하기(shell) / 


/ 5.1 Django Shell /

만들어진 모델을 "Django Shell" 로 사용해보자 

Ex)
    (mysite) c:\projects\mysite> python manage.py shell
    Python 3.9.6 (tags/v3.9.6:db3ff76, Jun 28 2021, 15:26:21) [MSC v.1929 64 bit (AMD64)] on win32
    Type "help", "copyright", "credits" or "license" for more information.
    (InteractiveConsole)
    >>>

"python manage.py shell" 명령어를 실행하면 ">>>" 으로 "Django Shell" 이 실행된 것을 확인할 수 있다.

이제 아까 migrate 했던 모델들을 shell 을 통해서 사용해보자

Ex)
    >>> from pybo.models import Question, Answer
    >>> from django.utils import timezone
    >>> q = Question(subject='pybo가 무엇인가요?', content='pybo에 대해서 알고 싶습니다.', create_date=timezone.now())
    >>> q.save()

"Question 모델" 을 만들 때, 작성했던 함수들에 대한 값들일 적어 넣어서 사용하면 된다.
모델을 사용했으면 save() 를 꼭 해자
"create_date" 안에 넣은 값은 현재 날짜를 출력해주는 "timezone" 함수를 불러와서 넣어주었다.


/ 5.2 모델 id /

"q" 라고 저장한 "Question 모델" 의 "id" 값을 불러오면 '1' 이라고 출력되는 것을 확인할 수 있다. 

Ex)
    >>> q.id
    1


"id" 는 모델 데이터의 유일한 값으로 기본 값("PK: Primary Key") 라고도 한다. 이 "id" 값은 데이터를 생성할 때마다 1씩 증가된다.

이제 2번째 질문을 만들어서 "id" 값이 어떻게 변하는지 확인해 보자

Ex)
    >>> q = Question(subject='장고 모델 질문입니다.', content='id는 자동으로 생성되나요?', create_date=timezone.now())
    >>> q.save()
    >>> q.id
    2


두번째로 생성된 질문의 "id" 는 예상대로 2라는 것을 알 수 있다.



/ 5.3 Question 조회 /

이제 만들어진 모델들을 조회해서 어떤 파일들이 생성되었는지 확인해 보자

Ex)
    >>> Question.objects.all()
    <QuerySet [<Question: Question object (1)>, <Question: Question object (2)>]>


저장한 "Question 모델" 은 "Question.objects" 명령을 통해 조회할 수 있다.
"Question.objects.all()" 명령은 모든 Question 모델의 데이터를 조회하는 함수이다.

결과적으로 "QuerySet 객체" 가 리턴되는데, Question 객체를 포함하고 있다.

"<Question: Question object (1)>, <Question: Question object (2)>" 에서 뒤에 붙은 1과 2는 id 값이다.



id 값이 아니라 "Question 모델" 을 만들 때 설정했던 subject 값으로 설정하고 싶다면 "pybo/models.py" 에 약간의 메서드를 추가해주면 된다.

Before)
    class Question(models.Model):
        subject = models.CharField(max_length=200)
        content = models.TextField()
        create_date = models.DateTimeField()


After)
    class Question(models.Model):
        subject = models.CharField(max_length=200)
        content = models.TextField()
        create_date = models.DateTimeField()
        def __str__ (self) :
            return self.subject()

이제 shell 을 종료하고 다시 실행해보면 값이 봐뀐 것을 확인할 수 있다. "django shell" 을 종료하고 싶으면, "Quit()" 을 입력하면 된다.


이제 "filter" 를 사용하여 id 값이 1인 "Question 데이터"를 조회해보자


Ex) 
    >>> Question.objects.filter(id=1)
    <QuerySet [<Question: pybo가 무엇인가요?>]>

"filter" 는 조건에 해당하는 데이터를 모두 리턴해주기 때문에 다건을 의미하는 "QuerySet" 이 리턴된다.



"id" 는 유일한 값이므로 filter 대신에 "get" 을 이용하여 조회할 수도 있다.

Ex)
    >>> Question.objects.get(id=1)
    <Question: pybo가 무엇인가요?>

"get" 으로 조회할 경우 QuerySet 이 아니라 "Question 모델" 객체가 리턴되었다. "filter" 는 여러 개를 리턴하지만 "get" 은 하나의 객체만 리턴하기 때문이다.



/ 5.4 Question 수정 /

이번에는 저장한 Question 데이터를 수정해 보자. 

Ex) 
    >>> q = Question.objects.get(id=2)
    >>> q
    <Question: 장고 모델 질문입니다.>
    >>> q.subject = 'Django Model Question'
    >>> q.save()
    >>> q
    <Question: Django Model Question>



/ 5.5 Question 삭제 /

이번에는 id 값이 1인 Question 데이터를 삭제해 보자.

Ex)
    >>> q = Question.objects.get(id=1)
    >>> q.delete()
    (1, {'pybo.Question': 1})


"(1, {'pybo.Question': 1})" 의 의미는 1번 데이터가 삭제됬다는 의미이다.



/ 6. Answer 작성 /

이제 답변 데이터를 생성해 보자

Ex) 
    >>> q = Question.objects.get(id=2)
    >>> q
    <Question: Django Model Question>
    >>> from django.utils import timezone
    >>> a = Answer(question=q, content='네 자동으로 생성됩니다.', create_date=timezone.now())
    >>> a.save()

    >>> a.id
    1

답변 데이터를 만들기 위해 질문이 필요하기에 id가 2인 question 데이터를 q 값에 저장한 후에 사용하였다.


/ 6.1 Answer 조회 /

Ex)
    >>> a = Answer.objects.get(id=1)
    >>> a
    <Answer: Answer object (1)>

"Answer 모델" 도 마찬가지로 id 값을 사용하면 된다.


Ex)
    >>> a.question
    <Question: Django Model Question>

"Answer 모델" 이 저장된 값 "a" 를 사용하면 연결된 질문도 조회할 수 있다.

"Answer 모델" 객체인 "a" 를 통해서 질문을 찾는 것은 "Answer 모델" 에 Question 속성이 연결되어 있기 때문에 매우 쉽다.



Ex)
    >>> q.answer_set.all()
    <QuerySet [<Answer: Answer object (1)>]>

"q.answer_set.all()" 을 사용하면 질문에 연결된 답변을 가져올 수 있다. "Question 모델" 에는 ansser_set 이라는 속성이 없지만 "Answer모델" 에 Question 모델이 ForeignKey 로 연결되어 있기 때문에, q.answer_set 과 같은 역방향 접근이 가능하다.

"연결모델명_set" 질문 하나에 여러개의 답변이 가능하므로 "q.answer_set" 이 가능하지만, 답변 하나에 여러개의 질문이 있을 수 없으므로 "a.question_set" 은 불가능하다. 답변 하나에는 질문 하나만 가능하기 때문에 a.question 만 가능하다.