/ 조회와 템플릿 /

1. 질문 목록
2. 질문 상세


/ -- 1 . 질문 목록 /

등록한 질문들을 게시물 목록으로 조회할 수 있는 기능을 구현해 보자.

현재 "http://localhost:8000/pybo/" 에 들어가면 "views.index" 에 구현해놓은 "HttpResponse" 함수에 따라서 "Hello Pybo" 라는 값이 구현 중이다.

이제 이 값을 수정하여 질문 목록을 받을 수 있도록 구현해보자.

Before)
  from django.http import HttpResponse

  def index(request) :
    return HttpResponse("Hello Pybodd")


After)
  from django.shortcuts import render
  from .models import Question


  def index(request):
      question_list = Question.objects.order_by('-create_date')
      context = {'question_list': question_list}
      return render(request, 'pybo/question_list.html', context)


"Question.objects.order_by('-create_date')" 의 의미를 하나씩 풀어 보자.

"order_by()" 의 의미는 함수 안에 넣는 값을 순서로 조회결과를 정렬하는 함수이다.

"order_by(-create_date)" 여기서 "-" 값이 들어간 의미는 역순으로 정렬한다는 의미이다. 당연히 "-" 가 없으면 순방향으로 정렬이 된다. 게시물은 최신순으로 글을 보기 때문에 역방향으로 정렬을 한다.


"render" 함수는 "파이썬 데이터를 템플릿에 적용하여 HTML로 반환해주는 함수"이다. 

즉, 위에서 사용한 "render" 함수는 질문 목록으로 조회한 "question_list" 데이터를 "pybo/question_list.html" 파일에 적용하여 "HTML" 을 생성후 리턴해준다.

여기서 사용된 'pybo/question_list.html' 과 같은 파일을 템플릿"(Template)" 라고 부른다. 

Html 파일과 비슷하지만 파이썬 데이터를 읽어서 사용할 수 있는 Html 파일이라는 점에서 차이가 난다.



/ -- 1.1 템플릿 디렉터리 /

이제 "render" 함수에서 사용한 "pybo/question_list.html" 템플릿 파일을 작성해야 한다. 하지만 이를 만들기 위해서는 먼저 해야할게 있다. 프로젝트 세팅파일에 들어가서 템플릿 디렉터리의 이름을 내가 만들 템플릿 디렉터리의 이름으로 교체해줘야 한다.

"config/setting.py" 

Ex)
  TEMPLATES = [
      {
          'BACKEND': 'django.template.backends.django.DjangoTemplates',
          'DIRS': [BASE_DIR / 'templates'],
          'APP_DIRS': True,
          'OPTIONS': {
              'context_processors': [
                  'django.template.context_processors.debug',
                  'django.template.context_processors.request',
                  'django.contrib.auth.context_processors.auth',
                  'django.contrib.messages.context_processors.messages',
              ],
          },
      },
  ]

'DIRS' 의 초기 모습은 : ( 'DIRS' : [] )이다.

여기에서 'BASE_DIR' 의 의미는 "C:/projects/mysite" 이므로 추가한 디렉터리의 전체 경로는 "C:/projects/mysite/templates" 이다.

기본적으로 장고는 "DIR" 에 설정한 디렉터리 외에도 앱 디렉터리 바로 하위에 있는 templates 디렉터리도 템플릿 디렉터리로 인식한다. 

즉, pybo 앱의 경우 다음의 디렉터리를 생성하면 별다른 설정없이 템플릿 디렉터리로 인식한다.

"projects/mysite/pybo/templates"

하지만 이처럼 "App" 디렉터리 하위에 템플릿 디렉터리를 두는 방법은 별조 좋은 방법이 아니다. 그 이유는 하나의 웹 사이트에서 여러 앱을 사용할 때 여러 앱의 화면을 구성하는 템플릿은 하나의 디렉터리에 모아 관리하는 편이 더 좋기 때문이다.

예를 들어, 여러 앱이 공통으로 사용하는 공통 템플릿을 어디에 저장해야 하는 경우가 생긴다면 앱마다 각각 존재하는 것보다 더 편리하게 구성할 수 있기 때문이다.

따라서 pybo앱은 "projects/mysite/pybo/templates" 가 아닌, "projects/mysite/template/pybo" 의 디렉터리를 만들어서 관리를 할 것이며, 그 외에 공통으로 사용하는 템플릿은 "projects/mysite/templates" 위치에 저장하면 된다.



/ -- 1.2 템플릿 파일 / 

"시스템 연동이 기억이 안난다면 매우중요 파일로 가서 확인하자"

이제 templates 폴더를 만들고 'pybo/question_list.html' 을 만들자.

render 함수에서 사용했던 templates 파일명에 따라서 "templates/pybo/question_list.html" 파일을 추가하자.

그리고 html 파일안에 다음과 같이 추가하면 된다.

Ex)
  {% if question_list %}
      <ul>
      {% for question in question_list %}
          <li><a href="/pybo/{{ question.id }}/">{{ question.subject }}</a></li>
      {% endfor %}
      </ul>
  {% else %}
      <p>질문이 없습니다.</p>
  {% endif %}


{% if question_list %} question_list 가 있다면

{% for question in question_list %} question_list를 순회하며 순차적으로 하나씩 question 에 대입

{{ question.id }} for 문에 의해 대입된 question 객체의 id번호를 출력한다.

{{ question.subject }} for문제 의해 대입된 question 객체의 제목을 출력한다.

/  분기  / 

Ex)
  {% if 조건문1 %}
      <p>조건문1에 해당되는 경우</p>
  {% elif 조건문2 %}
      <p>조건문2에 해당되는 경우</p>
  {% else %}
      <p>조건문1, 2에 모두 해당되지 않는 경우</p>
  {% endif %}

/  반복  /

Ex)
  forloop.counter 루프내의 순서로 1부터 표시한다

  forloop.counter0 루프내의 순서로 0부터 표시한다

  forloop.first 루프의 첫번째 순서인 경우 True

  forloop.last 루프의 마지막 순서인 경우 True

/  객체  /

Ex)
  {{ 객체 }}
  {{ 객체.속성 }}
  {{question.id}}, {{question.subject}}



/ -- 2 . 질문 상세 /

질문이 만들어 졌지만 그 질문들을 클릭을 하면 "page not found (404)" 오류가 발생한다.

그 이유는 아직 질문을 타고 들어갈 URL 매핑이 없기 때문이다.



/ -- 2.1 urls.py /

이제 "localhost:8000/pybo/2" 의 값을 매핑할 url을 정의하자

"pybo.urls.py"

Ex)
  from django.urls import path
  from . import views

  urlpatterns = [
      path('', views.index),
      path('<int:question_id>/', views.detail),
  ]

여기서 "<int:question_id>" 라고 지정해준 이유는 차후 "views.detail" 함수를 만들때 
"Question.objects.get(id=question_id)" 로 지정하여 id 값을 "question_id" 로 저장할 것이기 때문이다.

그리고 "<int:뭐시기>" 가 만들어지면 여기서 "int"는 숫자가 매핑된다는 뜻이다.


/ -- 2.2 views.py /

이제 "urls.py" 에서 설정한 "detail" 함수를 "views.py" 에서 구현하면 된다.

Ex)
  def detail(request, question_id) :
    question = Question.objects.get(id=question_id)
    context = {'question': question}
    return render(request, 'pybo/question_detail.html', context)


/ -- 3 . 오류 페이지 /

이번에는 "http://localhost:8000/pybo/30/" 페이지를 요청해 보자.

이렇게 검색을 하면 "DoseNotExist" 오류가 발생한다. 이 오류는 전달된 "question_id" 30이기 때문에 "Question.object.get(id=30)" 이기 때문에 발생한 오류이다. 이 때 전달되는 오류코드는 (500) 이다. 이렇게 없는 데이터를 요청할 경우 500 오류페이지보다는 "Not Found(404)" 페이지를 리턴하는 것이 바람직하다.

"pybo/views.py"

Before)
  from django.shortcuts import render
  from .models import Question

  def index(request) :
    question_list = Question.objects.order_by("create_date")
    context = {'question_list': question_list}
    return render(request, 'pybo/question_list.html', context)

  def detail(request, question_id) :
    question = Question.objects.get(id=question_id)
    context = {'question': question}
    return render(request, 'pybo/question_detail.html', context)


After)
  from django.shortcuts import render, get_object_or_404
  from .models import Question

  def index(request) :
    question_list = Question.objects.order_by("create_date")
    context = {'question_list': question_list} 
    return render(request, 'pybo/question_list.html', context)


  def detail(request, question_id):
      question = get_object_or_404(Question, pk=question_id)
      context = {'question': question}
      return render(request, 'pybo/question_detail.html', context)

"Question.objects.get(id = question_id)" 를 "get_object_or_404(question, pk=question_id)" 로 교체했다. 여기서 pk는 "Question 모델" 의 "Pirmary Key" 값을 의미하며,

뒤에 들어간 함수에서 살펴볼 것은 get object로 (Question, 라는 모델에서 , pk 값을 = question_id 값으로 준다는 뜻이다.)

