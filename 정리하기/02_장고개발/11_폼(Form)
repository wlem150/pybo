/ 폼(Form) /

1. 질문등록
2. 답변등록


/ 1. 질문등록 /

질문을 등록하자.

이를 등록하기 위해서는 먼저 질문 등록하기 버튼을 만들어야 한다.

"pybo/question_list.html"

Ex)
  </table>
      <a href="{% url 'pybo:question_create' %}" class="btn btn-primary">질문 등록하기</a>
  </div>

"btn btn-primary" 버튼이 보인다 버튼을 클릭하면 pybo:question_create 로 이동하게 된다.


/ 1.1 URL 매핑 /

이제 'pybo:question_create' 별칭에 해당되는 URL 매핑 규칙을 만들자.

"pybo/urls.py"

Ex)
  urlpatterns = [
      (... 생략 ...)
      path('question/create/', views.question_create, name='question_create'),
  ]


/ 1.2 폼(Form) /

흐름에 따라 "views.question_create" 함수를 작성해야 한다. 하지만 뷰 함수를 작성하기 전에 폼에 대해서 먼저 알아야 한다.

폼(Form) 은 페이지 요청시 전달되는 피라미터들을 쉽게 관리하기 위해 사용하는 클래이스이다. 폼은 필수 피라미터의 값이 누락되지 않았는지, 피라미터의 형식은 적절한지 등을 검증할 목적으로 사용된다. 이 외에도 HTML을 자동으로 생성하거나, 폼에 연결된 모델을 이용하여 데이터를 저장하는 기능도 있다.

이제 "forms.py" 라는 신규 파일을 작성하자.

"pybo/forms.py"

Ex)
  from django import forms
  from pybo.models import Question

  class QuestionForm(forms.ModelForm):
    class Meta:
      model = Question # 사용할 모델
      fields = ['subject', 'content'] # QuestionForm에서 사용할 Qeustion 모델의 속성


"QuestionForm" 은 모델폼 "forms.ModelForm" 을 상속했다. 장고의 폼은 "일반 폼 forms.Form" 과 "모델폼 forms.ModelForm" 이 있는데, 모델 폼은 "모델(Model) 과 연결된 폼"으로 폼을 저장하면 연결된 모델의 데이터를 저장할 수 있는 폼이다. 모델 폼은 이너 클래스인 "Meta 클래스"가 반드시 필요하다. "Meta 클래스"에는 사용할 모델과 모델의 속성을 반드시 적어야 한다.

즉, "QuestionForm" 은 "Qeustion 모델"과 연결된 폼이고 속성으로 "Question 모델의 subject, content 를 사용"한다고 정의한 것이다.


/ 1.3 뷰 함수 /

이제 폼을 작성했으니 다시 돌아와 뷰 함수를 작성하자


"pybo/views.py"

Ex)
  def question_create(request) :
    form = QuestionForm()
    return render(request, 'pybo/question_form.html', {'form':form})


question_create 함수는 미리 작성한 QuestionForm 을 사용했다. render 함수에 전달한 {'form':form} 은 템플릿에서 질문 등록시 사용할 폼 엘리먼트를 생성할 때 쓰인다.


/ 1.4 템플릿 /

이제 템플릿을 작성할 차례이다.

"templates/pybo/question_form.html"

Ex)
  {% extends 'base.html' %}
  {% block content %}
  <div class="container">
      <h5 class="my-3 border-bottom pb-2">질문등록</h5>
      <form method="post">
          {% csrf_token %}
          {{ form.as_p }}
          <button type="submit" class="btn btn-primary">저장하기</button>
      </form>
  </div>
  {% endblock %}


템플릿에서 사용한 {{form.as_p}} 의 "form은 question_create 함수에서 전달한 QuestionForm 의 객체"이다.

여기서 살펴보아야 할 점은 "form method = 'post'" 처럼 form 태그에 "action" 속성을 지정하지 않았다는 점이다. 보통 form 태그에는 항상 "action" 속성을 지정하여 submit 실행시 action에 정의된 URL로 폼을 전송해야 한다. 하지만 여기서는 특별하게 action 속성을 지정하지 않았다. form 태그에 action 속성을 지정하지 않으면 현재 페이지의 URL의 딜포트 action으로 설정된다.

물론 다음과 같이 action 속성을 명확하게 지정해도 된다.

Ex)
  <form method="post" action="{% url 'pybo:question_create'%}"

하지만 이렇게 하면 question_form.html 템플릿은 "질문 등록" 에서만 사용 가능하다. 이후에 진행할 "질문 수정" 에서는 이 템플릿을 활용할 수 없다. 왜냐하면 질문 수정일 경우에는 action 값을 달리 해야 하기 때문이다. 동일한 템플릿을 여러 기능에서 함께 사용할 경우에는 이처럼 form의 action 속성을 비워두는 트릭을 종종 사용한다. 우리는 이후에 "질문 수정" 기능을 구현할 때도 question_form.html 템플릿을 사용할 것이므로 action 속성은 비워두도록 하자. 


/ 1.5 GET 과 POST /

이제 구현이 되었는지 확인해 보자

로컬서버로 접속해서 질문을 등록을 해보아도 아무것도 나타나지 않는다. 왜냐하면 question_create 함수에 데이터를 저장하는 코드를 아직 작성하지 않았기 때문이다.

"mysite/pybo/views.py"

Ex)
  def question_create(request):
    if request.method == 'POST':
        form = QuestionForm(request.POST)
        if form.is_valid():
            question = form.save(commit=False)
            question.create_date = timezone.now()
            question.save()
            return redirect('pybo:index')
    else:
        form = QuestionForm()
    context = {'form': form}
    return render(request, 'pybo/question_form.html', context)


중요한 부분

가장 눈에 띄는 부분은 동일한 URL 요청을 POST, GET 요청 방식에 따라 다르게 처리한 부분이다. 질문 목록 화면에서 "질문 등록하기" 버튼을 클릭한 경우에는 /pybo/question/create/ 페이지가 GET 방식으로 요청되어 question_create 함수가 실행된다. 왜냐하면 <a href="{% url 'pybo:question_create' %}" class="btn btn-primary">질문 등록하기</a>와 같이 링크를 통해 페이지를 요청할 경우에는 무조건 GET 방식이 사용되기 때문이다. 따라서 이 경우에는 request.method 값이 GET이 되어 if .. else .. 구문에서 else 구문을 타게 되어 질문을 등록하는 화면을 렌더링한다.

그리고 질문 등록 화면에서 subject, content 항목에 값을 기입하고 "저장하기" 버튼을 누르면 이번에는 /pybo/question/create/ 페이지를 POST 방식으로 요청한다. 왜냐하면 앞서 설명했듯이 form 태그에 action 속성이 지정되지 않으면 현재 페이지가 디폴트 action으로 설정되기 때문이다.

따라서 질문 등록 화면에서 "저장하기" 버튼을 클릭하면 question_create 함수가 실행되고 request.method 값은 POST가 되어 다음 코드 블록이 실행될 것이다.

Ex)
    if request.method == 'POST':
        form = QuestionForm(request.POST)
        if form.is_valid():  # 폼이 유효하다면
            question = form.save(commit=False)  # 임시 저장하여 question 객체를 리턴받는다.
            question.create_date = timezone.now()  # 실제 저장을 위해 작성일시를 설정한다.
            question.save()  # 데이터를 실제로 저장한다.
            return redirect('pybo:index')

GET 방식에서는 form = QuestionForm() 처럼 QuestionForm을 인수 없이 생성했지만 POST 방식에서는 form = QuestionForm(request.POST) 처럼 request.POST를 인수로 생성했다. request.POST를 인수로 QuestionForm을 생성할 경우에는 request.POST에 담긴 subject, content 값이 QuestionForm의 subject, content 속성에 자동으로 저장되어 객체가 생성된다.

request.POST에는 화면에서 사용자가 입력한 내용들이 담겨있다.

그리고 form.is_valid()는 form이 유효한지를 검사한다. 만약 form에 저장된 subject, content의 값이 올바르지 않다면 form에는 오류 메시지가 저장되고 form.is_valid()가 실패하여 다시 질문 등록 화면을 렌더링 할 것이다.

 form.save(commit=False)는 form에 저장된 데이터로 Question 데이터를 저장하기 위한 코드이다. QuestionForm이 Question 모델과 연결된 모델 폼이기 때문에 이와 같이 사용할 수 있다. 여기서 commit=False는 임시 저장을 의미한다. 즉, 실제 데이터는 아직 데이터베이스에 저장되지 않은 상태를 말한다. 여기서 form.save(commit=False) 대신 form.save()를 수행하면 Question 모델의 create_date에 값이 없다는 오류가 발생할 것이다. 왜냐하면 QuestionForm에는 현재 subject, content 속성만 정의되어 있고 create_date 속성은 없기 때문이다. 이러한 이유로 임시 저장을 하여 question 객체를 리턴받고 create_date에 값을 설정한 후 question.save()로 실제 데이터를 저장하는 것이다.

 create_date 속성은 데이터 저장 시점에 생성해야 하는 값이므로 QuestionForm에 등록하여 사용하지 않는다.



/ 1.6 폼 위젯 /

{{ form.as_p }} 태그는 HTML 코드를 자동으로 생성하기 때문에 부트스트랩을 적용할 수가 없다.

"mysite/pybo/forms.py"

Ex)
  from django import forms
  from pybo.models import Question


  class QuestionForm(forms.ModelForm):
      class Meta:
          model = Question
          fields = ['subject', 'content']
          widgets = {
              'subject': forms.TextInput(attrs={'class': 'form-control'}),
              'content': forms.Textarea(attrs={'class': 'form-control', 'rows': 10}),
          }


위와 같이 widgets 속성을 지정하면 subject, content 입력 필드에 form-control과 같은 부트스트랩 클래스를 추가할 수 있다.



/ 1.7 폼 레이블 /

질문 등록 화면에 표시되는 'Subject', 'Content'를 영문이 아니라 한글로 표시하고 싶다면 다음처럼 labels 속성을 지정하면 된다.


"mysite/pybo/forms.py"

Ex)
  from django import forms
  from pybo.models import Question


  class QuestionForm(forms.ModelForm):
      class Meta:
          model = Question
          fields = ['subject', 'content']
          widgets = {
              'subject': forms.TextInput(attrs={'class': 'form-control'}),
              'content': forms.Textarea(attrs={'class': 'form-control', 'rows': 10}),
          }
          labels = {
              'subject': '제목',
              'content': '내용',
          }  


/ 1.8 수동 폼 작성 /

{{ form.as_p }}를 사용하면 빠르게 템플릿을 만들 수 있지만 HTML 코드가 자동으로 생성되므로 디자인 측면에서 많은 제한이 생긴다. 예를 들어 폼 엘리먼트 내에 특정 태그를 추가하거나 필요한 클래스를 추가하는 작업에 제한이 생긴다. 또 디자인 영역과 서버 프로그램 영역이 혼재되어 웹 디자이너와 개발자의 역할을 분리하기도 모호해진다.

이번에는 폼을 이용하여 자동으로 HTML 코드를 생성하지 말고 직접 HTML 코드를 작성하는 방법을 사용해 보자. 우선 수작업시 필요없는 widget 속성을 제거하자.


"mysite/pybo/forms.py"

Ex)
  from django import forms
  from pybo.models import Question


  class QuestionForm(forms.ModelForm):
      class Meta:
          model = Question  # 사용할 모델
          fields = ['subject', 'content']  # QuestionForm에서 사용할 Question 모델의 속성
          labels = {
              'subject': '제목',
              'content': '내용',
          }


"templates\pybo\question_form.html"

Ex)
{% extends 'base.html' %}

{% block content %}
<div class="container">
    <h5 class="my-3 border-bottom pb-2">질문등록</h5>
    <form method="post">
        {% csrf_token %}
        <!-- 오류표시 Start -->
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field in form %}
            {% if field.errors %}
            <div>
                <strong>{{ field.label }}</strong>
                {{ field.errors }}
            </div>
            {% endif %}
            {% endfor %}
        </div>
        {% endif %}
        <!-- 오류표시 End -->
        <div class="mb-3">
            <label for="subject" class="form-label">제목</label>
            <input type="text" class="form-control" name="subject" id="subject"
                   value="{{ form.subject.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="content" class="form-label">내용</label>
            <textarea class="form-control" name="content"
                      id="content" rows="10">{{ form.content.value|default_if_none:'' }}</textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장하기</button>
    </form>
</div>
{% endblock %}

매우 중요한 사항

하나씩 뜯어보자 

"question_list.html" 에서 질문하기 버튼을 누르면 그 값이 ulrs.py 에 들어가고 그곳에 있는 views.question_create 함수 값을 불러오게 된다. "a 태그" 는 특별하게 method 값을 지정해주지 않으면 전달방식이 무조건 get 방식을 취하게 된다. 그래서 "question_create 함수" 에서 나오는 값은
 form = QuestionForm() 이라는 값이 생기게 된다.
 context = {'form':form} 다시 재할당을 해주고
 return render(request, 'pybo/question_form.html', context) 'pybo/question_form.html' 값을 만들어 주게 된다.

"pybo/question_form.html" 

Ex)
{% extends 'base.html' %}
{% block content %}
<div class = "container">
  <h5 class="my-3 border-bottom pb-2">질문등록</h5>
  <form method="post">
    {% csrf_token %}
<div class="mb-3">
        <label for="subject" class="form-label">제목</label>
        <input type="text" class="form-control" name="subject" id="subject"
               value="{{ form.subject.value|default_if_none:'' }}">
    </div>
    <div class="mb-3">
        <label for="content" class="form-label">내용</label>
        <textarea class="form-control" name="content"
                  id="content" rows="10">{{ form.content.value|default_if_none:'' }}</textarea>
    </div>
  <button type="submit" class="btn btn-primary">저장하기</button>
  </form>
</div>
{% endblock content %}

오류 영역은 잠깐 빼고 살펴본다면, html, css 와 관련된 내용은 전부 배재한 채로 하나씩 살펴볼 때

Ex)
<label for="subject" class="form-label">제목</label>
        <input type="text" class="form-control" name="subject" id="subject"
               value="{{ form.subject.value|default_if_none:'' }}">

label for = "subject" 이 속성은 id와 같으면 연결된다. 그렇기 때문에, input id = "subject" 와 연결되어 있다는 말이다.

label class = "form-label" 이 값은 단순히 bootstrap 에서 사용하는 css 클래스이다.

input class = "form-control" 마찬가지로 bootstrap 에서 사용하는 css 클래스이다.

제목(subject) 항목의 value = {{ form.subject.value|default_if_none:'' }} 처럼 값을 대입해 주었는데 이것은 오류가 발생했을 경우 기존에 입력했던 값을 유지하기 위함이다.
|default_if_none:''의 의미는 폼 데이터(form.subject.value)에 값이 없을 경우 None 이라는 문자열이 표시되는데 None 대신 공백으로 표시하라는 의미의 템플릿 필터이다.



이제 여기서 공백으로 파일을 넘길 경우 오류가 발생을 하는데 그 오류가 발생했을 시에 발생하는 값들이다.

Ex)
        <!-- 오류표시 Start -->
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field in form %}
            {% if field.errors %}
            <div>
                <strong>{{ field.label }}</strong>
                {{ field.errors }}
            </div>
            {% endif %}
            {% endfor %}
        </div>
        {% endif %}
        <!-- 오류표시 End -->

공백으로 넘기면 오류가 발생하는 이유에 대해서 설명하기 이전에 알아야 하는 설명이 있다.

저장하기 버튼을 누르게 되면 다시 리로드되면서 url 에 따라서 홈페이지가 찾아가는 곳이 urls.py 이다. 그리고 그곳에서 
views.question_create 함수를 다시 실행하는데, 처음 question_list.html 파일에서 만들 때에는 "a 태그" 를 사용했기 때문에 get 방식으로 넘어가서 question_form.html 파일을 랜더링 했지만, question_form.html 파일이 만들어 질 때 form 태그의 method가 post 형식으로 만들어 졌다. 따라서 저장하기 버튼을 누르면 post 방식으로 views.question_create 함수가 실행이 되고, POST 방식을 사용했기 때문에, 이 값들이 실행되게 된다.

Ex)
if request.method == 'POST':
    form = QuestionForm(request.POST)
    if form.is_valid():
      question = form.save(commit=False)
      question.create_date = timezone.now()
      question.save()
      return redirect('pybo:index')

그래서 이 값들이 들어갈 때 오류가 발생을 하는 것인데, 오류가 나는 이유는 아무런 전달값도 없이 QuestionForm(request.POST) 에 대한 값으로 forms.py 에 전달 받아도 아무값도 찾을 수 없으며, 

if form.is_valid(): 에 값이 들어가면서 form 에 대한 값으로 공백이 들어가면서 유효하지 못하고, 이 함수가 False 를 반환한다. 그에 따라 에러가 발생하고, 밑에 있는 

Ex)
  form = QuestionForm()
  context = {'form':form}
  return render(request, 'pybo/question_form.html', context)

가 다시 실행되며, 페이지가 다시 리로딩되는데, 단순히 위에 오류 표시가 새로 생기는 것처럼 보이는 이유는 이미 전달받은 데이터 값, 캐시값이 존재하기 때문이다.

그래서 그 오류값과 함께 반환된 페이지가 다시 만들어지는 것이다.

if form.errors  가 발생하게 된다.

Ex)
  <!-- 오류표시 Start -->
          {% if form.errors %}
          <div class="alert alert-danger" role="alert">
              {% for field in form %}
              {% if field.errors %}
              <div>
                  <strong>{{ field.label }}</strong>
                  {{ field.errors }}
              </div>
              {% endif %}
              {% endfor %}
          </div>
          {% endif %}
          <!-- 오류표시 End -->

Ex)
  class QuestionForm(forms.ModelForm):
    class Meta:
      model = Question # 사용할 모델
      fields = ['subject', 'content'] # QuestionForm에서 사용할 Qeustion 모델의 속성
      widgets = {
        'subject': forms.TextInput(attrs={'class':'form-control'}),
        'content': forms.TextInput(attrs={'class':'form-control', 'row': 15})
      }
      labels = {
        'subject' : '제목 ',
        'content' : '내용 ',
      }
      
if form.errors 란 즉 사용자가 제대로 된 값을 전달하지 않아서 웹페이지 사이트가 리로딩되면서 화면에 뜨는 css값이라고 할 수 있다.

그래서 여기서 form 값은 QuestionForm() 값에 정의된 값에서 데이터가 나오게 된다.

위에 있는 html 파일을 하나씩 뜯어보면 


{% if form.errors %} 

만약에 form 이 에러가 있다면

여기서 form 은 question_create 함수에 들어가면서 만들어지고 리턴 받은 값을 뜻한다.

<div class="alert alert-danger" role="alert">

이 값은 bootstrap 에서 찾을 수 있는 값으로 빨간색 색깔의 화면을 표시해준다.

{% for field in form %}

form 에 저장되어 있는 값들을 field 라는 변수에 넣어주면서 밑에 있는 값들을 실행해주는 반복문이다.

{% if field.errors %}

form 에 있는 값들에 따라 그 값이 공백으로 저장되었다면 에러가 발생한 것으로 가정한다. 그리고 field 에 들어온 form 값이 에러가 참이라면 밑에 있는 구문들이 실행이 되면서 위와 같은 값들이 출력이 된다.

<strong>{{ field.label }}</strong>

여기에 나와있는 label 의 값은 question_create 함수에 들어갈 때 form = QuestionForm() 에 들어가면서 가졌던 labels 의 값을 받아와서 출력이 된다.

{{ field.errors }}

이도 위와 마찬가지 이다.




여기서 생각해봐야 하는 점은 

{% if field.errors %} 이 구문이다.

위에서 이미 {% if form.errors %} 라는 값을 주고 {% for field in form %} 라는 값으로 errors 구문을 실행하면 되는데 반복문을 할 때 넣은 값을 다시 if 문으로 field 의 에러값을 구하는 이유가 있다.

Ex)
          {% if form.errors %}
          <div class="alert alert-danger" role="alert">
              {% for field in form %}
              <div>
                  <strong>{{ field.label }}</strong>
                  {{ field.errors }}
              </div>
              {% endfor %}

"제목에만 값을 넣지않고 저장하기를 눌렀을 시 "
Ex)
제목
필수 항목입니다.
내용

if 문이 없이 저장하기로 값을 전달하게 되면 다음과 같은 오류가 발생한다. 그 이유는

question_create 함수에 들어갈 때 "제목"에 들어가는 "오류값" 하나와 "내용"에 들어가는 "참인값" 총 2개가 만들어지게 되고, form 에는 값이 2개가 되게 된다. 

둘 중에 하나만 오류가 발생해도 form.errors 가 발생하게 되는데, 그 값에 따라 for 문이 실행되어 지게 되었다.

그에 따라 오류가 발생하며 field.errors 구문이 자연스럽게 작성이 되지만, label 에 대한 값은 오류가 없어도 출력이 되기 때문에, 원하지 않던 값을 받게 된다

form = QuestionForm() 의 값으로 들어갔을 때

"제목과 내용 모두 없다는 가정으로"

form 의 배열값은 form = ['subject', 'content'] 이다.

  class Meta:
    model = Question # 사용할 모델
    fields = ['subject', 'content']


이에 따라 반복문에 들어가는 field 값 또한 1번 과 2번이 나누어서 들어가고 각각 찾아지는 값들이 달라지게 된다. 




/ -- 2. 답변 등록 /

이번에는 질문 등록에 장고 폼을 적용한 것처럼 답변 등록에도 장고 폼을 적용해 보자. 답변을 등록할 때 사용할 AnswerForm을 pybo/forms.py 파일에 다음과 같이 작성하자

"mysite/pybo/forms.py"

Ex)
  from django import forms
  from pybo.models import Question, Answer

  (... 생략 ...)

  class AnswerForm(forms.ModelForm):
      class Meta:
          model = Answer
          fields = ['content']
          labels = {
              'content': '답변내용',
          }


이제 answer_create 함수를 수정하자

"mysite/pybo/views.py"

Ex)
  def answer_create(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    if request.method == 'POST':
      if form.is_valid():
        form = AnswerForm(request.POST)
        answer = form.save(commit=False)
        answer.create_date = timezone.now()
        answer.question = question
        answer.save()
        return redirect('pybo:detail',question_id = question.id)
    else :
      return HttpResponseNotAllowed("Only POST is possible.")
    context = {'question':question, 'form':form}
    return render(request, 'pybo/question_detail.html',context)

question_create와 같은 방법으로 AnswerForm을 이용하도록 변경했다. 하지만 답변 등록은 POST 방식만 사용되기 때문에 GET 방식으로 요청할 경우에는 HttpResponseNotAllowed 오류가 발생하도록 했다.

그리고 질문 상세 템플릿도 오류를 표시하기 위한 영역을 다음처럼 추가하자.

"templates/pybo/question_detail.html"

Ex)
        {% if form.errors %}
        <div class="alert alert-danger" role="alert">
            {% for field in form %}
            {% if field.errors %}
            <div>
                <strong>{{ field.label }}</strong>
                {{ field.errors }}
            </div>
            {% endif %}
            {% endfor %}
        </div>
        {% endif %}


