/ 페이징 /

1. 대량 테스트 페이지 만들기
2. Pginator
3. 템플릿에 페이징 적용하기
4. 페이지 리스트


/ -- 1. 대량 테스트 페이지 만들기 /

현재 구현한 질문 목록은 페이징 처리가 안되기 때문에 게시물 300개를 작성하면 한 페이지에 300개의 게시물 모두가 표시된다. 페이징 문제를 해결하자


/ 1.1 대량 테스트 데이터 만들기 /

페이징을 테스트할 수 있을 정도로 충분한 데이터를 생성하자. 대량의 테스트 데이터를 만드는 가장 좋은 방법은 "장고셸"을 이용하는 것이다.

Ex)
  python manage.py shell

  from django.utils import timezone
  from pybo.models import Question

  for i in range(300):
    q = Question(subject="테스트페이지 입니다. [%d] %i", content = "내용무", create_date = timezone.now())
    q.save()



/ -- 2. Pginator /

장고에서 페이징을 위해 사용하는 클래스는 Paginator 이다. Paginator 클래스를 사용하여 다음과 같이 index 함수에 페이징 기능을 적용해 보자.

"pybo/views.py"

Ex)
  from django.shortcuts import render, get_object_or_404, redirect
  from django.utils import timezone
  from .models import Question, Answer
  from .forms import QuestionForm, AnswerForm
  from django.core.Paginator import Paginator

  def index(request):
    page = request.GET.get('page', '1') #페이지
    question_list = Question.objects.order_by("-create_date")
    Paginator = Paginator(question_list, 10)
    page_obj = Paginator.get_page(page)
    context = {'question_list':page_obj}
    return render(request, 'pybo:question_list.html',context)

page = request.GET.get('page','1') 은 "http://localhost:8000/pybo/?page=1" 처럼 GET 방식으로 호출된 URL에서 page값을 가져올 때 사용한다. 만약 "http://localhost:8000/pybo/" 처럼 page값 없이 호출된 경우에는 디폴트로 1이라는 값을 설정한다.

paginator = Paginator(question_list, 10) 은 페이지당 10개씩 보여주도록 했다.

page_obj = paginator.get_page(page) 그리고 paginator를 이용하여 요청된 페이지(page)에 해당되는 페이징 객체(page_obj)를 생성했다. 이렇게 하면 장고 내부적으로는 데이터 전체를 조회하지 않고 해당 페이지의 데이터만 조회하도록 쿼리가 변경된다.

"왜 변경되고, 왜 변경해야하는지, 어디서 변경된 사항을 확인할 수 있는지 등등 에대해서는 나와있지가 않음"

paginator.count	전체 게시물 개수
paginator.per_page	페이지당 보여줄 게시물 개수
paginator.page_range	페이지 범위
number	현재 페이지 번호
previous_page_number	이전 페이지 번호
next_page_number	다음 페이지 번호
has_previous	이전 페이지 유무
has_next	다음 페이지 유무
start_index	현재 페이지 시작 인덱스(1부터 시작)
end_index	현재 페이지의 끝 인덱스(1부터 시작)


/ -- 3. 템플릿에 페이징 적용하기 /

index 함수에서 질문 목록 템플릿(pybo/question_list.html)에 전달한 데이터(context)는 다음과 같다.

Ex)
context = {'question_list': page_obj}  # question_list는 페이징 객체(page_obj)
return render(request, 'pybo/question_list.html', context)

따라서 질문 목록 템플릿에 전달된 페이징 객체는 question_list이다. 이제 페이징 객체인 question_list를 이용하여 템플릿에서 어떻게 페이징을 처리할수 있는지 알아보자.

"templates/pybo/question_list.html"

Ex)
    </table>
    <!-- 페이징처리 시작 -->
    <ul class="pagination justify-content-center">
        <!-- 이전페이지 -->
        {% if question_list.has_previous %}
        <li class="page-item">
            <a class="page-link" href="?page={{ question_list.previous_page_number }}">이전</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <a class="page-link" tabindex="-1" aria-disabled="true" href="#">이전</a>
        </li>
        {% endif %}
        <!-- 페이지리스트 -->
        {% for page_number in question_list.paginator.page_range %}
        {% if page_number == question_list.number %}
        <li class="page-item active" aria-current="page">
            <a class="page-link" href="?page={{ page_number }}">{{ page_number }}</a>
        </li>
        {% else %}
        <li class="page-item">
            <a class="page-link" href="?page={{ page_number }}">{{ page_number }}</a>
        </li>
        {% endif %}
        {% endfor %}
        <!-- 다음페이지 -->
        {% if question_list.has_next %}
        <li class="page-item">
            <a class="page-link" href="?page={{ question_list.next_page_number }}">다음</a>
        </li>
        {% else %}
        <li class="page-item disabled">
            <a class="page-link" tabindex="-1" aria-disabled="true" href="#">다음</a>
        </li>
        {% endif %}
    </ul>
    <!-- 페이징처리 끝 -->
    <a href="{% url 'pybo:question_create' %}" class="btn btn-primary">질문 등록하기</a>
</div>
{% endblock %}

이전 페이지가 있는 경우에는 "이전" 링크가 활성화되게 하였고 이전 페이지가 없는 경우에는 "이전" 링크가 비활성화되도록 하였다. (다음페이지의 경우도 마찬가지 방법으로 적용되었다.) 그리고 페이지 리스트를 루프 돌면서 해당 페이지로 이동할 수 있는 링크를 생성하였다. 이때 현재 페이지와 같을 경우에는 active클래스를 적용하여 강조표시도 해 주었다.

이전 페이지가 있는지 체크	{% if question_list.has_previous %}
이전 페이지 번호	{{ question_list.previous_page_number }}
다음 페이지가 있는지 체크	{% if question_list.has_next %}
다음 페이지 번호	{{ question_list.next_page_number }}
페이지 리스트 루프	{% for page_number in question_list.paginator.page_range %}
현재 페이지와 같은지 체크	{% if page_number == question_list.number %}

페이지 리스트를 보기 좋게 표시하기 위해 부트스트랩의 pagination 컴포넌트를 이용하였다. 템플릿에 사용한 pagination, page-item, page-link 등이 부트스트랩 pagination 컴포넌트의 클래스이다.



/ -- 4. 페이지 리스트 /

페이징 처리는 잘 되었지만 한 가지 문제를 발견할 수 있다. 문제는 위에서 보듯이 이동할 수 있는 페이지가 모두 표시된다는 점이다.

"\templates\pybo\question_list.html"

Ex)
<!-- 페이지리스트 -->
{% for page_number in question_list.paginator.page_range %}
{% if page_number >= question_list.number|add:-5 and page_number <= question_list.number|add:5 %}
{% if page_number == question_list.number %}
<li class="page-item active" aria-current="page">
    <a class="page-link" href="?page={{ page_number }}">{{ page_number }}</a>
</li>
{% else %}
<li class="page-item">
    <a class="page-link" href="?page={{ page_number }}">{{ page_number }}</a>
</li>
{% endif %}
{% endif %}
{% endfor %}
