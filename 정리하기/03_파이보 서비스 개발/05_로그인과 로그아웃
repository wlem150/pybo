/ 로그인과 로그아웃 /

파이보는 여러 사람이 사용하는 질문 답변 게시판이다. 하지만 현재까지 파이보에는 회원가입 기능도 로그인, 로그아웃 기능도 없었다. 질문을 올린 사람, 답변을 올린 사람을 구별하기 위해서는 로그인과 로그아웃 기능이 필수이다.

로그인, 로그아웃을 도와주는 앱은 "django.contrib.authp" 이다.

이 앱은 장고 프로젝트 생성시 다음처럼 자동으로 추가된다.


"mysite\config\settings.py"

INSTALLED_APPS = [
    'pybo.apps.PyboConfig',
    'django.contrib.admin',
    ('django.contrib.auth'),
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]

"djanog.contrib.auth" 앱을 이용하면 로그인과 로그아웃 기능을 쉽게 구현이 가능하다.

1. common 앱
2. 로그인
6. 로그아웃


/ -- 1. common 앱 /

로그인과 로그아웃은 pybo앱에 구현하는 것은 좋지 않다. 하나의 웹사이트에는 게시판 외에도 블로그나, 쇼핑물과 같은 거대한 단위의 앱들이 함께 있을 수 있기 때문에 공통으로 사용되는 기능인 로그인이나 로그아웃을 이 중의 하나의 앱에 종속시키는 것은 비효율적이다.

그래서 로그인과 로그아웃을 "공통 기능을 가진 앱" 이라는 의미의 "common" 앱에 구현하자

"(mysite) c:\projects\mysite>django-admin startapp common"



common 앱이 자동으로 만들어지면 setting.py 에 앱을 등록하자

"mysite\config\settings.py"

Ex)
  INSTALLED_APPS = [
      'common.apps.CommonConfig',  
      'pybo.apps.PyboConfig',
      'django.contrib.admin',
      'django.contrib.auth',
      'django.contrib.contenttypes',
      'django.contrib.sessions',
      'django.contrib.messages',
      'django.contrib.staticfiles',
  ]

common 앱의 urls.py 파일을 사용하기 위해 config/urls.py 파일을 다음과 같이 수정하자

"config/urls.py"

Ex)
  from django.contrib import admin
  from django.urls import payh, include

  urlpatterns = [
      path('admin/', admin.site.urls),
      path('pybo/', include('pybo.urls')),
      path('common/', include('common.urls')),
  ]


그리고 common/urls.py 파일을 신규로 작성하자.


"mysite\common\urls.py"

Ex)
  app_name = 'common'

  urlpatterns = [
    
  ]


/ -- 2. 로그인 /

로그인 기능을 구현해보자. 로그인의 시작은 로그인 화면이다. 로그인 화면으로 진입할 수 있도록 "templates/naver.html"파일의 '로그인' 링크를 다음처럼 수정하자.


"templates/naver.html"

Ex)
  <ul class="navbar-nav">
      <li class="nav-item ">
          <a class="nav-link" href="{% url 'common:login' %}">로그인</a>
      </li>
  </ul>


/ 2.1 로그인 뷰 /


"navbar.html" 파일에서 탬플릿 태그로 {% url 'common:login'%} 를 사용했으므로 common.urls.py 파일에 URL 매핑 규칙을 추가하자.

"common/urls.py"

Ex)
  from django.urls import path
  from django.contrib.auth import views as auth_views

  app_name = 'common'

  urlpatterns = [
      path('login/', auth_views.LoginView.as_view(), name='login'),
  ]

로그인 뷰는 따로 만들 필요없이 위 코드처럼 django.contrib.auth 앱의 Loginview 를 사용하도록 설정했다.



/ 2.2 로그인 템플릿 /

여기까지 수정하고 브라우저에서 내비게이션바의 '로그인' 링크를 눌러 보자. 

"registration" 디렉터리에 "login.html" 파일이 없음을 의미한다. 앞서 사용한 LoginView 함수는 registration 이라는 템플릿 디렉터리에서 login.html 파일을 찾는다. 그런데 파일을 찾기 못해 오류가 발생한 것이다.

이 오류를 해결하기 위해서는 "registration/login.html" 템플릿 파일을 작성해야 한다.

그렇지만 로그인은 common 앱에 구현할 것이므로 오류 메세지에 표시한 것처럼 registration 디렉터리에 템플릿파일을 생성하지 않고 common 디렉터리에 템플릿을 생성하는 것이 좋다.

이를 위해 LoginView 가 common 디렉터리의 템플릿을 참조할 수 있도록 "common/urls.py" 파일을 다음과 같이 수정하자.


"common/urls.py"

Ex)
  from django.urls import path
  from django.contrib.auth import views an auth_views

  app_name = 'common'

  urlpatterns = [
    path('common/', auth_views.LoginView.as_view(templates_name ='common/login.html'), name='common')
  ]

이렇게 수정하면 이제 registration 디렉터리가 아닌 common 디렉터리에서 login.html 파일을 참조하게 된다.


제 common/login.html 파일을 생성하기 위해 common 템플릿 디렉터리를 다음과 같이 생성하고 login.html 파일을 만들어보자


"templates/common/login.html"

Ex)
{% extends "base.html" %}
{% block content %}
<div class="container my-3">
    <form method="post" action="{% url 'common:login' %}">
        {% csrf_token %}
        {% include "form_errors.html" %}
        <div class="mb-3">
            <label for="username">사용자ID</label>
            <input type="text" class="form-control" name="username" id="username"
                   value="{{ form.username.value|default_if_none:'' }}">
        </div>
        <div class="mb-3">
            <label for="password">비밀번호</label>
            <input type="password" class="form-control" name="password" id="password"
                   value="{{ form.password.value|default_if_none:'' }}">
        </div>
        <button type="submit" class="btn btn-primary">로그인</button>
    </form>
</div>
{% endblock %}


사용자ID와 비밀번호를 입력으로 받아 로그인하는 간단한 템플릿이다. 로그인에 사용되는 사용자ID를 의미하는 "username"과 비밀번호를 의미하는 "password" 항목은 "django.contrib.auth 앱이 요구하는 하는 필수항목"이다.

[django.contrib.auth 인증시 다음 2개의 항목은 반드시 필요하다]

username - 사용자명
password - 비밀번호

그리고 {% csrf_token %} 바로 밑에 include 태그로 포함된 form_errors.html 템플릿 파일은 다음과 같이 작성하자.



"templates\form_errors.html"

Ex)
<!-- 필드 오류와 넌필드 오류를 출력한다. -->
{% if form.errors %}
<div class="alert alert-danger">
    {% for field in form %}
    <!-- 필드 오류 -->
    {% if field.errors %}
    <div>
        <strong>{{ field.label }}</strong>
        {{ field.errors }}
    </div>
    {% endif %}
    {% endfor %}
    <!-- 넌필드 오류 -->
    {% for error in form.non_field_errors %}
    <div>
        <strong>{{ error }}</strong>
    </div>
    {% endfor %}
</div>
{% endif %}

"form_errors.html" 템플릿은 로그인 실패시 로그인이 왜 실패했는지 알려주는 역할을 한다. 폼 오류에는 다음과 같이 두 가지 종류의 오류가 있다.

필드 오류 (field.errors)
넌필드 오류 (form.non_field_errors)

"필드 오류"는 사용자가 입력한 필드 값에 대한 오류로 값이 누락되었거나 필드의 형식이 일치하지 않는 경우에 발생하는 오류이다. "넌필드 오류"는 필드의 값과는 상관없이 다른 이유로 발생하는 오류이다. "form_errors.html" 템플릿은 필드 오류와 넌필드 오류 모두를 표시하기 위해 삽입되는 템플릿이다.

question_form.html, question_detail.html 템플릿에서 오류를 표시하기 위해 추가했던 HTML코드를 {% include "form_errors.html" %} 으로 대체해도 좋다.


/ 2.3 로그인 수행 /

입력값을 누락하거나 엉뚱한 값으로 로그인하려고 시도하면 다음처럼 그에 해당하는 오류메시지가 표시될 것이다.

현재 로그인이 가능한 사용자는 슈퍼유저로 생성한 "admin" 뿐이다. 사용자 ID에 admin을 입력하고 비밀번호에 1111을 입력하여 로그인을 수행해 보자.

아마 page not found(404) 오류가 발생할 것이다.

오류가 발생한 이유는 로그인이 성공하면 "django.contrib.auth 패키지는 디폴트로 /accounts/profile/ 이라는 URL로 이동시키기 때문"이다.

로그인은 성공한 것이 맞다.

다만 /accounts/profile/ URL은 현재 우리가 파이보에 구성한 URL 구조와 맞지 않으므로 로그인 성공 시 / 페이지로 이동할 수 있도록 "config/settings.py" 파일을 수정하자. 마지막 줄에 "LOGIN_REDIRECT_URL"을 추가하면 된다.

/ 페이지는 기본 URL인 http://localhost:8000/ 페이지를 의미한다.



"config\settings.py"

Ex)
  LOGIN_REDIRECT_URL = '/'



아직 여전히 오류는 남아있다.

왜냐하면 '/'를 의미하는 'http://localhost:8000/' 페이지에 대한 URL 매핑 규칙을 작성하지 않았기 때문이다.

이제 "config/urls.py "파일에 / 페이지에 대응하는 URL 매핑 규칙을 추가하자.


"config\urls.py"

Ex)
from django.contrib import admin
from django.urls import path, include
from pybo import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('pybo/', include('pybo.urls')),
    path('common/', include('common.urls')),
    path('', views.index, name='index'),  # '/' 에 해당되는 path
]

이렇게 수정하면 '/' 페이지 요청에 대해 path('', views.index, name='index')가 작동하여 pybo/views.py 파일의 index 함수가 실행된다.



/ -- 3. 로그아웃 /

로그인에 성공했지만, 내비게이션바에는 여전히 "로그인" 링크가 보인다. 로그인 후에는 "로그인" 링크가 "로그아웃" 링크로 바뀌어야 할 것이다.

"navbar.html" 템플릿 파일에서 로그인 링크 부분을 수정하자


"templates\navbar.html"

Ex)
<li class="nav-item">
    {% if user.is_authenticated %}
    <a class="nav-link" href="{% url 'common:logout' %}">{{ user.username }} (로그아웃)</a>
    {% else %}
    <a class="nav-link" href="{% url 'common:login' %}">로그인</a>
    {% endif %}
</li>


{% if user.is_authenticated %} 은 현재 사용자가 로그인 되었는지를 판별한다. 따라서 로그인이 되어 있으면 "로그아웃" 링크를 표시하고 로그인이 되어 있지 않다면 "로그인" 링크를 표시할 것이다.



"템플릿에서 User 사용하기"
뷰함수에서 템플릿에 User 객체를 전달하지 않더라도 템플릿에서는 django.contrib.auth 기능으로 인해 User 객체를 사용할 수 있다. 대표적으로 다음과 같은 것들이 있다.

"user.is_authenticated" - 현재 사용자가 인증되었는지 여부 (로그인한 상태라면 true, 로그아웃 상태라면 false)
"user.is_anonymous" - is_authenticated의 반대 경우 (로그인한 상태라면 false, 로그아웃 상태라면 true)
"user.username" - 사용자명 (사용자 ID)
"user.is_superuser"- 사용자가 슈퍼유저인지 여부
보다 자세한 내용은 다음을 참고하자.


로그아웃 링크가 추가되었으므로 {% url 'common:logout' %}에 대응하는 URL 매핑을 common/urls.py 파일에 추가해야 한다.


"common/urls.py"

Ex)
  from django.urls import path
  from django.contrib.auth import views as auth_views

  app_name = 'common'

  urlpatterns = [
      path('login/', auth_views.LoginView.as_view(template_name='common/login.html'), name='login'),
      path('logout/', auth_views.LogoutView.as_view(), name='logout'),
  ]


그리고 로그아웃 시 리다이렉트할 위치도 config/settings.py 파일에 추가하자.


"config\settings.py"

Ex)
  # 로그인 성공후 이동하는 URL
  LOGIN_REDIRECT_URL = '/'

  # 로그아웃시 이동하는 URL
  LOGOUT_REDIRECT_URL = '/'


